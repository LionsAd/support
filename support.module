<?php
// $Id$

/**
 * @file support.module
 */

/**
 * TODO items:
 *  3. Configurable auto-reply to new tickets
 *  6. Client form validation
 */

/**
 * Implementation of hook_node_info().
 */
function support_node_info() {
  return array(
    'support_ticket' => array(
      'name' => t('Support ticket'),
      'module' => 'support',
      'description' => t('A <em>support ticket</em>.'),
    ),
  );
}

/**
 * Implementation of hook_acces().
 */
function support_access($op, $node, $account) {
  switch ($op) {
    case 'create':
      return user_access('create tickets', $account);
  }
}

/**
 * Implementation of hook_menu().
 */
function support_menu() {
  $items['support'] = array(
    'title' => 'Support tickets',
    'page callback' => 'support_page',
    'page arguments' => array(),
    'access callback' => 'support_access_clients',
    'access arguments' => array(),
  );
  // TODO: Figure out how to use the 6.x menu system correctly, this feels a
  // little sloppy.
  $result = db_query('SELECT clid, path, name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    $items["support/$client->path"] = array(
      'title' => "$client->name",
      'page callback' => 'support_page',
      'page arguments' => array($client->clid),
      'access callback' => 'support_access_clients',
      'access arguments' => array($client, TRUE),
    );
    $states = array('all' => 'all', 'all open' => 'all open') + _support_states();
    foreach ($states as $sid => $state) {
      $items["support/$client->path/$state"] = array(
        'title' => "$state",
        'page callback' => 'support_page',
        'page arguments' => array($client->clid, $state),
        'access callback' => 'support_access_clients',
        'access arguments' => array($client, TRUE),
        'weight' => $sid,
        'type' => $sid == 'all open' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      );
    }
  }
  $result = db_query('SELECT clid, path, name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    $states = array('all' => 'all', 'all open' => 'all open') + _support_states();
    foreach ($states as $sid => $state) {
      $items["support/$state"] = array(
        'title' => "$state",
        'page callback' => 'support_page',
        'page arguments' => array($client->clid, $state),
        'access callback' => 'support_access_clients',
        'access arguments' => array($client),
        'weight' => $sid,
        'type' => $sid == 'all open' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      );
    }
  }
  $items['support/user/%user_uid_optional'] = array(
    'page callback' => 'support_page_user',
    'page arguments' => array(2),
    'access callback' => 'support_page_user_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'support.user.inc',
  );
  $items['support/%user_uid_optional/assigned'] = array(
    'title' => 'My tickets',
    'page callback' => 'support_page_user',
    'page arguments' => array(1, TRUE),
    'access callback' => 'support_page_user_access',
    'access arguments' => array(1),
    'file' => 'support.user.inc',
  );
  $items['support/%node/unsubscribe/%user/%'] = array(
    'page callback' => 'support_unsubscribe_user',
    'page arguments' => array(1, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['support/all/unsubscribe/%user/%'] = array(
    'page callback' => 'support_unsubscribe_user',
    'page arguments' => array('all', 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['admin/support'] = array(
    'title' => 'Support',
    'description' => 'Manage the support tickets.',
    'position' => 'right',
    'weight' => 5,
    'page callback' => 'support_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'support.admin.inc',
  );
  $items['admin/support/clients'] = array(
    'title' => 'Clients',
    'description' => 'Manage clients.',
    'page callback' => 'support_admin_client_overview',
    'access arguments' => array('administer support'),
    'file' => 'support.admin.inc',
  );
  $items['admin/support/clients/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/support/clients/%support_client/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('support_admin_client', 3),
    'access arguments' => array('administer support'),
    'file' => 'support.admin.inc',
  );
  $items['admin/support/clients/%support_client/fetch'] = array(
    'title' => 'Fetch mail',
    'type' => MENU_CALLBACK,
    'page callback' => 'support_client_fetch',
    'page arguments' => array(3),
    'access arguments' => array('administer support'),
    'file' => 'support.admin.inc',
  );
  $items['admin/support/clients/add'] = array(
    'title' => 'Add client',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('support_admin_client'),
    'access arguments' => array('administer support'),
    'file' => 'support.admin.inc',
  );
  $items['admin/support/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('support_admin_settings'),
    'access arguments' => array('administer support'),
    'file' => 'support.admin.inc',
  );
  return $items;
}

function support_cron() {
  $clients = support_active_clients();
  foreach ($clients as $clid => $client) {
    support_client_fetch($client, FALSE); 
  }
}

/**
 * Load all active clients.
 */
function support_active_clients() {
  static $clients = NULL;

  if (is_null($clients)) {
    $result = db_query('SELECT * FROM {jobtrack_client} WHERE status = 1');
    while ($client = db_fetch_object($result)) {
      $clients[$client->clid] = $client;
    }
  }
  return $clients;
}

/**
 * Unsubscribe user from tickets.
 */
function support_unsubscribe_user($node, $account, $key) {
  // unsubscribe from a single node
  if (is_object($node) && is_object($account)) {
    $lock = md5($account->uid . $node->nid);
    if ($key == $lock) {
      db_query('UPDATE {jobtrack_assigned} SET active = 0 WHERE uid = %d AND nid = %d', $account->uid, $node->nid);
      drupal_set_message(t('%email has been unsubscribed from ticket %ticket.', array('%email' => $account->mail, '%ticket' => $node->title)));
    }
    else {
      drupal_set_message(t('Invalid key, failed to unsubscribe %email.', array('%email' => $account->mail)), 'error');
    }
    drupal_goto("node/$node->nid");
  }
  else if (is_object($account)) {
    $lock = md5($account->uid);
    if ($key == $lock) {
      db_query('UPDATE {jobtrack_assigned} SET active = 0 WHERE uid = %d', $account->uid);
      drupal_set_message(t('%email has been unsubscribed from all tickets.', array('%email' => $account->mail)));
    }
    else {
      drupal_set_message(t('Invalid key, failed to unsubscribe %email.', array('%email' => $account->mail)), 'error');
    }
  }
  drupal_goto('');
}

/**
 * Custom permissions function.
 */
function support_access_clients($client = NULL, $quantity = NULL) {
  if (is_object($client)) {
    if ($quantity === TRUE) {
      // menu for displaying multiple clients
      return (user_access("access $client->name tickets") &&
              (_support_access_tickets() > 1));
    }
    else {
      // menu for displaying only one client
      return (user_access("access $client->name tickets") &&
              (_support_access_tickets() == 1));
    }
  }
  else {
    return _support_access_tickets();
  }
}

/**
 * Menu callback, load a client.
 */
function support_client_load($clid) {
  static $clients = array();
  if (!isset($clients[$clid])) {
    $clients[$clid] = db_fetch_object(db_query('SELECT * FROM {jobtrack_client} WHERE clid = %d', $clid));
  }
  return $clients[$clid];
}

/**
 * Menu callback, load a ticket.
 */
function support_ticket_load($nid) {
  $tickets = array();
  if (!isset($tickets[$nid])) {
    $tickets[$nid] = db_fetch_object(db_query('SELECT * FROM {jobtrack_ticket} WHERE nid = %d', $nid));
  }
  return $tickets[$nid];
}

/**
 * Extract domains.
 */
function _support_domains($client, $global) {
  $domains = array();
  $string = "$client, $global";
  $raw = explode(',', $string);
  foreach ($raw as $domain) {
    if ($domain) {
      $domains[] = trim($domain);
    }
  }
  return $domains;
}

/**
 * Match up a user account with an incoming email.  Create account if email
 * doesn't match any.
 * TODO: Make it possible to assign multiple email addresses to one account.
 */
function support_account_load($from, $ticket, $subject) {
  $uid = db_result(db_query("SELECT uid FROM {users} WHERE mail = '%s'", $from));
  if ($uid) {
    return user_load($uid);
  }
  else {
    // extract the domain out of the from email address
    preg_match("/(.*)@(.*)/", $from, $matches);
    $domain = $matches[2];
    $ticket = support_ticket_load($ticket);
    $client = support_client_load($ticket->client);
    $domains = _support_domains($client->domains, variable_get('jobtrack_global_domains', ''));
    $valid = TRUE;
    if (!empty($domains)) {
      $valid = FALSE;
      foreach ($domains as $match) {
        if ($domain == $match) {
          $valid = TRUE;
        }
      }
    }
    // TODO: this isn't a role, this is a permission
    //$role = "access $client->name tickets";
    if ($valid) {
      watchdog('support', 'User !username automatically created.', array('!username' => $from), WATCHDOG_NOTICE);
      //return user_save(NULL, array('mail' => $from, 'init' => $from, 'name' => $from, 'status' => 1, 'roles' => array($role)));
      return user_save(NULL, array('mail' => $from, 'init' => $from, 'name' => $from, 'status' => 1));
    }
    else {
      $node = node_load($ticket);
      watchdog('support', 'Email update from !from denied for ticket "!title", subject "!subject."', array('!from' => $from, '!title' => $node->title, '!subject' => $subject), WATCHDOG_NOTICE);
      return FALSE;
    }
  }
}

/**
 *
 */
function support_client_name_load($name) {
  return db_fetch_object(db_query("SELECT * FROM {jobtrack_client} WHERE name = '%s'"));
}

/**
 * Implementation of hook_perm().
 */
function support_perm() {
  $perm = array('administer support', 'create tickets', 'edit own ticket', 'administer state');
  $result = db_query('SELECT name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    $perm[] = "access $client->name tickets";
  }
  return $perm;
}

/**
 * Implementation of hook_user().
 */
function support_user($type, &$edit, &$user) {
  if ($type == 'view' && user_access('create tickets', $user)) {
    $user->content['summary']['support'] = array(
      '#type' => 'user_profile_item',
      '#title' => t('Tickets'),
      '#value' => l(t('View recent tickets'), "support/user/$user->uid", array('attributes' => array('title' => t("Read @username's latest tickets.", array('@username' => $user->name))))),
      '#attributes' => array('class' => 'support'),
    );
  }
}

/**
 * Implementation of hook_form().
 */
function support_form(&$node) {
  $type = node_get_types('type', $node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => !empty($node->title) ? $node->title : NULL,
    '#weight' => -5,
  );

  $reference = array();
  $form = array_merge($form, support_status_form($reference, $node, ''));

  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);

  $form = array_merge($form, support_subscribe_form($reference, $node, ''));

  return $form;

}

/**
 * Implementation of hook_nodeapi().
 */
function support_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      return db_fetch_array(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket} WHERE nid = %d', $node->nid));
    case 'validate':
      if (!$node->client) {
        form_set_error('client', t('You must select a client'));
      }
      break;
    case 'insert':
    case 'update':
      db_query('UPDATE {jobtrack_ticket} SET state = %d, priority = %d, client = %d, assigned = %d WHERE nid = %d', $node->state, $node->priority, $node->client, $node->assigned, $node->nid);
      if (!db_affected_rows()) {
        db_query('INSERT INTO {jobtrack_ticket} (nid, state, priority, client, assigned) VALUES(%d, %d, %d, %d, %d)', $node->nid, $node->state, $node->priority, $node->client, $node->assigned);
      }
      if ($op == 'insert') {
        // auto-subscribe configured users
        _support_autosubscribe($node->nid, $node->client);
        // auto-subscribe ticket creator
        support_subscribe_user($node->nid, $node->uid, $node->notification);
        // generate notification emails
        support_notification(0, $node->nid, 'ticket_new');
      }
      cache_clear_all();
      break;
    case 'delete':
      db_query('DELETE FROM {jobtrack_ticket} WHERE nid = %d', $node->nid);
      break;
  }
}

/**
 * Implementation of hook_comment().
 */
function support_comment(&$comment, $op) {
  switch ($op) {
    case 'view':
      support_comment_view($comment);
      break;
    case 'insert':
    case 'update':
      db_query('UPDATE {jobtrack_ticket_comment} SET state = %d, priority = %d, client = %d, assigned = %d WHERE cid = %d', $comment['state'], $comment['priority'], $comment['client'], $comment['assigned'], $comment['cid']);
      if (!db_affected_rows()) {
        db_query('INSERT INTO {jobtrack_ticket_comment} (cid, state, priority, client, assigned) VALUES(%d, %d, %d, %d, %d)', $comment['cid'], $comment['state'], $comment['priority'], $comment['client'], $comment['assigned']);
      }
      _support_comment_update_node($comment['nid']);
      if ($op == 'insert') {
        // auto-subscribe configured users
        _support_autosubscribe($comment['nid'], $comment['client']);
        // auto-subscribe ticket-comment creator
        support_subscribe_user($comment['nid'], $comment['uid'], $comment['notification']);
        // auto-subscribe assigned user
        if ($comment['assigned']) {
          support_subscribe_user($comment['nid'], $comment['assigned'], 1);
        }
        // generate notification emails
        support_notification($comment['cid'], $comment['nid']);
      }
      break;
    case 'delete':
      db_query('DELETE FROM {jobtrack_ticket_comment} WHERE cid = %d', $comment->cid);
      _support_comment_update_node($comment->nid);
  }
}

/**
 * Display state, priority and client when viewing comments for support nodes.
 */
function support_comment_view(&$comment) {
  static $state = 0;
  static $priority = 0;
  static $client = 0;
  static $assigned = 0;
  $current = db_fetch_object(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket_comment} WHERE cid = %d', $comment->cid));
  if ($assigned != $current->assigned) {
    $previous_account = user_load(array('uid' => $assigned));
    $current_account = user_load(array('uid' => $current->assigned));
    $comment->comment = '<div class="support-assigned">Assigned: '. ($previous_account->name ? $previous_account->name : '<em>'. t('unassigned') .'</em>') .' -> '. ($current_account->name ? $current_account->name : '<em>'. t('unassigned') .'</em>') ."</div>\n". $comment->comment;
    $assigned = $current->assigned;
  }
  if ($client != $current->client) {
    $comment->comment = '<div class="support-client">Client: '. _support_client($client) .' -> '. _support_client($current->client) ."</div>\n". $comment->comment;
    $client = $current->client;
  }
  if ($state != $current->state) {
    $comment->comment = '<div class="support-state">State: '. _support_state($state) .' -> '. _support_state($current->state) ."</div>\n" . $comment->comment;
    $state = $current->state;
  }
  if ($priority != $current->priority) {
    $comment->comment = '<div class="support-priority">Priority: '. _support_priorities($priority) .' -> '. _support_priorities($current->priority) ."</div>\n" . $comment->comment;
    $priority = $current->priority;
  }
}

/**
 * Implementation of hook_mail().
 */
function support_mail($key, &$message, $params) {
  $language = $message['language'];
  $variables = support_mail_tokens($params['account'], $language, $params['nid'], $params['cid']);
  $message['subject'] .= _support_mail_text($key .'_subject', $language, $variables);
  $message['body'] = _support_mail_text($key .'_body', $language, $variables);
}

/**
 * Return an array of token to value mappings for support e-mail messages.
 */
function support_mail_tokens($account, $language, $nid, $cid) {
  global $base_url;
  static $reset = TRUE;
  // force reload node from database to get updated state/priority information,
  // but no need to reset it multiple times when sending multiple notifications
  $node = node_load($nid, NULL, $reset);
  $reset = FALSE;
  $comment = _comment_load($cid);
  $update_account = user_load($comment->uid);
  $ticket_unsubscribe_key = md5($account->uid . $node->nid);
  $all_unsubscribe_key = md5($account->uid);
  $previous_comment = db_result(db_query_range('SELECT cid FROM {comments} WHERE nid = %d ORDER BY cid DESC', $nid, 1, 1));
  if ($previous_comment) {
    $previous = db_fetch_object(db_query('SELECT * FROM {jobtrack_ticket_comment} WHERE cid = %d', $previous_comment));
  }
  $tokens = array(
    '!username' => $account->name,
    '!key' => '['. variable_get('support_key', 'tkt') .":$nid]",
    '!update_username' => $update_account->name,
    '!site' => variable_get('site_name', 'Drupal'),
    '!uri' => $base_url,
    '!uri_brief' => preg_replace('!^https?://!', '', $base_url),
    '!mailto' => $account->mail,
    '!date' => format_date(time(), 'medium', '', NULL, $language->language),
    '!ticket_subject' => $node->title,
    '!ticket_body' => $node->body,
    '!ticket_url' => url("node/$nid", array('absolute' => TRUE, 'language' => $language, 'fragment' => "comment-$cid")),
    '!update_url' => url("node/$nid", array('absolute' => TRUE, 'language' => $language, 'fragment' => "comment-form")),
    '!update' => $comment->comment,
    '!state' => ((isset($previous->state) && $previous->state != $node->state) ? _support_state($previous->state) .' -> ' : '') . _support_state($node->state),
    '!priority' => ((isset($previous->priority) && $previous->priority != $node->priority) ? _support_priorities($previous->priority) .' -> ' : '') . _support_priorities($node->priority),
    '!unsubscribe_ticket' => url("support/$nid/unsubscribe/$account->uid/$ticket_unsubscribe_key", array('absolute' => TRUE, 'language' => $language)),
    '!unsubscribe_all' => url("support/all/unsubscribe/$account->uid/$all_unsubscribe_key", array('absolute' => TRUE, 'language' => $language)),
  );
  if (!empty($account->password)) {
    $tokens['!password'] = $account->password;
  }
  return $tokens;
}

/**
 * Returns the appropriate mail string for a given key.
 */
function _support_mail_text($key, $language = NULL, $variables = array()) {
  $langcode = isset($language) ? $language->language : NULL;

  if ($admin_setting = variable_get('support_mail_'. $key, FALSE)) {
    // An admin setting overrides the default string.
    return strtr($admin_setting, $variables);
  }
  else {
    // No override, return default string.
    switch ($key) {
      case 'ticket_new_subject':
        return t("!key !ticket_subject", $variables, $langcode);
      case 'ticket_new_body':
        return t("!username has created the ticket '!ticket_subject':\n!ticket_url\n\nState: !state\nPriority: !priority\n\nYou can reply to this email (do not modify the subject) or visit the following URL to update this ticket:\n!update_url\n\nTicket text:\n------------------------------\n!ticket_body\n------------------------------\n\nUnsubscribe from this ticket:\n!unsubscribe_ticket\n\nUnsubscribe from all tickets:\n!unsubscribe_all", $variables, $langcode);
      case 'ticket_comment_new_subject':
        return t("!key !ticket_subject", $variables, $langcode);
      case 'ticket_comment_new_body':
        return t("!update_username has updated the ticket '!ticket_subject':\n!ticket_url\n\nState: !state\nPriority: !priority\n\nYou can reply to this email (do not modify the subject) or visit the following URL to update this ticket:\n!update_url\n\nUpdate text:\n------------------------------\n!update\n------------------------------\n\nUnsubscribe from this ticket:\n!unsubscribe_ticket\n\nUnsubscribe from all tickets:\n!unsubscribe_all", $variables, $langcode);
    }
  }
}

/**
 * Save the message.
 */
function support_save_message($subject, $body, $from, $ticket, $client) {
  $account = support_account_load($from, $ticket, $subject);
  $ticket = support_ticket_load($ticket);
  if (is_object($account) && is_object($ticket) && $ticket->nid) {
    // by retrieving the maximum thread level.
    $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $ticket->nid));
    // Strip the "/" from the end of the thread.
    $max = rtrim($max, '/');
    // Finally, build the thread field for this new comment.
    $thread = int2vancode(vancode2int($max) + 1) .'/';
    // TODO: format?
    // TODO: ip_address?
    db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $ticket->nid, 0, $account->uid, $subject, $body, 1, ip_address(), time(), 0, $thread, $account->name, $account->mail, $account->homepage);

    // Tell the other modules a new comment has been submitted.
    $comment['cid'] = db_last_insert_id('comments', 'cid');
    $comment['subject'] = $subject;
    $comment['comment'] = $body;
    $comment['nid'] = $ticket->nid;
    $comment['uid'] = $account->uid;
    $comment['state'] = $ticket->state;
    $comment['priority'] = $ticket->priority;
    $comment['client'] = $ticket->client;
    comment_invoke_comment($comment, 'insert');

    // Add an entry to the watchdog log.
    watchdog('content', 'Comment: added %subject.', array('%subject' => $comment['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $comment['nid'], array('fragment' => 'comment-'. $comment['cid'])));
    _comment_update_node_statistics($comment['nid']);

    // Clear the cache so an anonymous user can see his comment being added.
    cache_clear_all();
    return TRUE;
  }
  else if (is_object($account)) {
    // Create new ticket if none matches and valid from address.
    $node->title = $subject;
    $node->body = $body;
    $node->type = 'support_ticket';
    $node->log = t('Support ticket created from email.');
    $node->comment = COMMENT_NODE_READ_WRITE;
    $node->uid = $account->uid;
    $node->state = _support_state_default();
    $node->priority = _support_priority_default();
    $node->client = $client->clid;
    node_save($node);
  }
}

function _support_get_message_body($stream, $message, $structure, $part = 1) {
  if (!empty($structure)) {
    $body = imap_fetchbody($stream, $message, $part);
    foreach ($structure->parameters as $parameter) {
      if (strtoupper($parameter->attribute) == 'CHARSET') {
        $encoding = $parameter->value;
        break;
      }
    }
    switch ($structure->encoding) {
      case 3: // base64
        $decoded = drupal_convert_to_utf8(imap_base64($body), $encoding);
        break;
      case 4: // quoted-printable
        $decoded = drupal_convert_to_utf8(quoted_printable_decode($body), $encoding);
        break;
      default:
        $decoded = drupal_convert_to_utf8($body, $encoding);
        break;
    }

    if ($decoded) {
      return ($decoded);
    }
    else {
      watchdog('support', t("Failed to convert message to utf8 -- using unconverted message.  To fix this, try installing iconv, GNU recode, or mbstring for PHP."));
      return ($body);
    }

  }
  return NULL;
}

/**
 * Subscribe a user to a ticket.
 */
function support_subscribe_user($nid, $uid, $active = 1) {
  db_query('UPDATE {jobtrack_assigned} SET active = %d WHERE uid = %d AND nid = %d', $active, $uid, $nid);
  if (!db_affected_rows()) {
    db_query('INSERT INTO {jobtrack_assigned} (nid, uid, active) VALUES(%d, %d, %d)', $nid, $uid, $active);
  }
}

/**
 * Autosubscribe users to new client ticket.
 */
function _support_autosubscribe($nid, $client) {
  $autosubscribe = db_result(db_query('SELECT autosubscribe FROM {jobtrack_client} WHERE clid = %d', $client));
  $autosubscribe = explode(',', $autosubscribe);
  foreach ($autosubscribe as $name) {
    $account = user_load(array('name' => $name));
    if (is_object($account) && $account->uid) {
      support_subscribe_user($nid, $account->uid);
    }
  }
}

/**
 * Send notification emails to everyone subscribed to the updated ticket.
 */
function support_notification($cid, $nid, $op = 'ticket_comment_new') {
  $result = db_query('SELECT uid FROM {jobtrack_assigned} WHERE nid = %d AND active = 1', $nid);
  while ($account = db_fetch_object($result)) {
    _support_mail_notify($op, user_load(array('uid' => $account->uid)), $cid, $nid);
  }
}

/**
 * Use drupal_mail to send email.
 */
function _support_mail_notify($op, $account, $cid = NULL, $nid = NULL, $language = NULL) {
  $notify = variable_get('support_mail_'. $op .'_notify', TRUE);
  if ($notify) {
    $node = node_load($nid);
    $mailfrom = db_result(db_query('SELECT mailfrom FROM {jobtrack_client} WHERE clid = %d', $node->client));
    $params['account'] = $account;
    $params['nid'] = $nid;
    $params['cid'] = $cid;
    $language = $language ? $language : user_preferred_language($account);
    $mail = drupal_mail('support', $op, $account->mail, $language, $params, $mailfrom);
    // TODO: notify admins as necessary
  }
  return empty($mail) ? NULL : $mail['result'];
}

/**
 * Helper function.
 */
function _support_comment_update_node($nid) {
  $cid = db_result(db_query('SELECT MAX(cid) FROM {comments} WHERE nid = %d', $nid));
  if ($cid) {
    $comment = db_fetch_object(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket_comment} WHERE cid = %d', $cid));
    db_query('UPDATE {jobtrack_ticket} SET state = %d, priority = %d, client = %d, assigned = %d WHERE nid = %d', $comment->state, $comment->priority, $comment->client, $comment->assigned, $nid);
  }
}

/**
 * Customize comment form for ticket followups.
 */
function support_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form') {
    $reference = array();
    $form = array_merge(support_status_form($form_state, $form, ''), $form);
    $form = array_merge($form, support_subscribe_form($reference, $form, ''));
  }
}

/**
 * Generate form for adding update to ticket.  Enhances comment_form.
 */
function support_status_form(&$form_state, $edit, $title) {
  $cid = 0;
  if (is_array($edit)) {
    if (is_array($edit['nid'])) {
      $node = node_load($edit['nid']['#value']);
      $cid = $edit['cid']['#value'];
    }
    else {
      $node = node_load($edit['nid']);
    }
  }
  else if (is_object($edit)) {
    $node = node_load($edit->nid);
  }
  if ($cid) {
    $comment = db_fetch_object(db_query('SELECT state, priority FROM {jobtrack_ticket_comment} WHERE cid = %d', $cid));
    if ($comment->state && $comment->priority) {
      $node->state = $comment->state;
      $node->priority = $comment->priority;
    }
  }
  $form['support'] = array(
    '#type' => 'fieldset',
    '#prefix' => '<div class="container-inline">',
    '#suffix' => '</div>',
  );
  $form['support']['state'] = array(
    '#type' => 'select',
    '#title' => t('State'),
    '#options' => _support_states(FALSE, $node->state),
    '#default_value' => $node->state ? $node->state : _support_state_default(),
  );
  $form['support']['space'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $form['support']['priority'] = array(
    '#type' => 'select',
    '#title' => t('Priority'),
    '#options' => _support_priorities(),
    '#default_value' => $node->priority ? $node->priority : _support_priority_default(),
  );
  $form['support']['space2'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $clients = _support_available_clients();
  if (sizeof($clients) == 1) {
    foreach ($clients as $key => $name) {
      $client = $key;
    }
    $node->client = $client;
  }
  else {
    $clients = array(0 => '- select client -') + $clients;
  }
  $form['support']['client'] = array(
    '#type' => 'select',
    '#required' => TRUE,
    '#title' => t('Client'),
    '#options' => $clients,
    '#default_value' => $node->client ? $node->client : 0,
  );
  $form['support']['space3'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $form['support']['assigned'] = array(
    '#type' => 'select',
    '#title' => t('Assigned'),
    '#options' => _support_assigned($node->assigned, $node),
    '#default_value' => $node->assigned ? $node->assigned : 0,
  );
  return $form;
}

/**
 * Get list of available users to assign ticket to.
 */
function _support_assigned($assigned, $node) {
  global $user;

  $available = array();

  // can only unassign tickets if assigned to self, or have admin permissions
  if (!$assigned || $assigned == $user->uid || 
      user_access('administer support')) {
    $available[0] = ' - '. t('not assigned') .' -';
  }

  if ($assigned && $assigned != $user->uid) {
    $account = user_load($assigned);
    $available[$account->uid] = $account->name;
  }

  // can always re-assign ticket to self
  $available[$user->uid] = $user->name;

  if ($node->client && user_access('administer support')) {
    $roles = array();
    $client = db_result(db_query('SELECT name FROM {jobtrack_client} WHERE clid = %d', $node->client));
    // retrieve all roles giving permission to access current tickets
    $result = db_query("SELECT rid FROM {permission} WHERE perm LIKE '%%%s%%'", "access $client tickets");
    while ($role = db_fetch_object($result)) {
      $roles[$role->rid] = $role->rid;
    }
    // retrieve all users in appropriate roles
    $accounts = array();
    $all = FALSE;
    foreach ($roles as $rid) {
      if ($rid == DRUPAL_AUTHENTICATED_RID) {
        $all = TRUE;
        $result = db_query('SELECT uid FROM {users} WHERE status = 1');
      }
      else {
        $result = db_query('SELECT r.uid FROM {users_roles} r LEFT JOIN {users} u ON r.uid = u.uid WHERE r.rid = %d AND u.status = 1', $rid);
      }
      while ($account = db_fetch_object($result)) {
        $accounts[$account->uid] = $account->uid;
      }
      // we've already retrieved all active users, no need to search more roles
      if ($all) break;
    }
    // load users and allow them to be assigned
    foreach ($accounts as $uid) {
      $account = user_load(array('uid' => $uid));
      $available[$account->uid] = $account->name;
    }
  }

  return $available;
}

/**
 * Provide option to subscribe/unsubscribe from ticket notification emails.
 */
function support_subscribe_form(&$form_state, $edit, $title) {
  global $user;
  $form = array();
  $form['subscribe'] = array(
    '#type' => 'fieldset',
    '#title' => t('Notifications'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  if (is_array($edit)) {
    $notification = db_result(db_query('SELECT active FROM {jobtrack_assigned} WHERE nid = %d AND uid = %d', $edit['nid']['#value'], $user->uid));
  }
  else {
    $notification = TRUE;
  }
  $form['subscribe']['notification'] = array(
    '#type' => 'checkbox',
    '#title' => t('Subscribe'),
    '#description' => t('Receive email notifications when this ticket is updated.'),
    '#default_value' => isset($notification) ? $notification : TRUE,
  );
  return $form;
}

/**
 * Load all active clients.
 */
function _support_clients_load($path = FALSE) {
  $result = db_query('SELECT clid, path, name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    if ($path) {
      $clients[$client->clid] = $client->path;
    }
    else {
      $clients[$client->clid] = $client->name;
    }
  }
  return $clients;
}

/**
 * Access callback for user support ticket pages.
 */
function support_page_user_access($account) {
  return $account->uid && user_access('access content') && (user_access('create tickets', $account) || _support_ticket_exists($account));
}

/**
 * Helper function to list available states.
 */
function _support_states($all = TRUE, $sid = NULL) {
  static $states = array();
  $admin = user_access('administer state');

  if (!isset($states["$admin-$all-$sid"])) {
    if ($admin || $all) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} ORDER BY weight");
    }
    else if (!$all && !$sid) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} WHERE phase1 = 1 ORDER BY weight");
    }
    else if (!$all) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} WHERE phase2 = 1 ORDER BY weight");
    }
    while ($state = db_fetch_object($result)) {
      $states["$admin-$all-$sid"][$state->sid] = $state->state;
    }
    // include the current state, even if user doesn't actually have access
    if ($sid && !in_array($sid, $states["$admin-$all-$sid"])) {
      $states["$admin-$all-$sid"][$sid] = db_result(db_query("SELECT state FROM {jobtrack_states} WHERE sid = %d", $sid));
    }
  }

  return $states["$admin-$all-$sid"];
}

/**
 * Return default sid.
 */
function _support_state_default() {
  static $default = NULL;
  if (!$default) {
    $default = db_result(db_query_range('SELECT sid FROM {jobtrack_states} WHERE isdefault = 1', 0, 1));
  }
  return $default;
}

/**
 * Helper function to list available priorities.
 */
function _support_priorities($pid = NULL) {
  static $priorities = array();

  if (empty($priorities)) {
    $result = db_query('SELECT pid, priority FROM {jobtrack_priority} ORDER BY weight');
    while ($priority = db_fetch_object($result)) {
      $priorities[$priority->pid] = $priority->priority;
    }
  }

  if ($pid && isset($priorities[$pid])) {
    return $priorities[$pid];
  }
  if ($pid === 0) {
    return '';
  }
  else {
    return $priorities;
  }
}

/**
 * Return default pid.
 */
function _support_priority_default() {
  static $default = NULL;
  if (!$default) {
    $default = db_result(db_query_range('SELECT pid FROM {jobtrack_priority} WHERE isdefault = 1', 0, 1));
  }
  return $default;
}

/**
 * Helper function to determine if a user has support tickets already.
 */
function _support_ticket_exists($account) {
  return (bool)db_result(db_query_range(db_rewrite_sql("SELECT 1 FROM {node} n WHERE n.type = 'support_ticket' AND n.uid = %d AND n.status = 1"), $account->uid, 0, 1));
}

/**
 * Helper function, retrieve state name from database.
 */
function _support_state($state) {
  static $state_name = array();

  if (!isset($state_name[$state])) {
    $state_name[$state] = db_result(db_query('SELECT state FROM {jobtrack_states} WHERE sid = %d', $state));
  }

  return $state_name[$state];
}

/**
 * Find all clients we have permission to view/edit.
 */
function _support_available_clients() {
  static $valid = array();

  if (empty($valid)) {
    $clients = _support_clients_load();
    foreach ($clients as $clid => $name) {
      if (user_access("access $name tickets")) {
        $valid[$clid] = $name;
      }
    }
  }
  return $valid;
}

/**
 *
 */
function _support_get_state($state) {
  if ($state == 'all') {
    return 0;
  }
  else if ($state == 'all open') {
    return -1;
  }
  $sid = db_result(db_query("SELECT sid FROM {jobtrack_states} WHERE state = '%s'", $state));
  if (!$sid) {
    $sid = _support_state_default();
  }
  return $sid;
}

/**
 * Display tickets
 */
function support_page($client = NULL, $state = NULL) {
  global $user;

  if (!$client) {
    $clients = _support_available_clients();
    if (sizeof($clients) > 1) {
      return t('Please select a client.');
    }
    else if (sizeof($clients) == 1) {
      foreach ($clients as $key => $name) {
        $client = $key;
      }
    }
  }

  if (!$state) {
    $state = 'all open';
  }
  $state = _support_get_state($state);

  $rows = array();
  $header = array(
    array('data' => t('Ticket'), 'field' => 'n.title'),
    array('data' => t('Updated'), 'field' => 'last_updated', 'sort' => 'desc'),
    array('data' => t('Reporter'), 'field' => 'n.uid'),
    array('data' => t('State'), 'field' => 't.state'),
    array('data' => t('Prioriy'), 'field' => 't.priority'),
    array('data' => t('Updates'), 'field' => 'l.comment_count'),
  );
  if ($state < 0) {
    // TODO: Make this configurable.
    $state = 'AND t.state != '. _support_get_state('closed');
  }
  else {
    $state = $state ? "AND t.state = $state" : '';
  }
  $sql = "SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count, t.state, t.priority FROM {node} n LEFT JOIN {jobtrack_ticket} t ON n.nid = t.nid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid WHERE (c.status = ". COMMENT_PUBLISHED ." OR c.status IS NULL) AND n.status = 1 AND client = $client $state";
  $sql = db_rewrite_sql($sql);
  $sql .= tablesort_sql($header);
  $sql_count = "SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND client = $client $state";
  $sql_count = db_rewrite_sql($sql_count);
  $result = pager_query($sql, 50, 0, $sql_cont);
  $rows = array();
  while ($ticket = db_fetch_object($result)) {
    $account = user_load(array('uid' => $ticket->uid));
    $comments = l($ticket->comment_count, "node/$ticket->nid", array('fragment' => 'comments'));
    if ($new = comment_num_new($ticket->nid)) {
      $node = node_load($ticket->nid);
      $comments .= '&nbsp;('. l(format_plural($new, '1 new', '@count new'), "node/$ticket->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new')) .')';
    }
    $rows[] = array(
      l($ticket->title, "node/$ticket->nid"),
      format_date($ticket->last_updated, 'small'),
      l($account->name, "user/$account->uid"),
      _support_state($ticket->state),
      _support_priorities($ticket->priority),
      $comments);
  }
  return theme('table', $header, $rows);
}

/**
 * Helper function, retrieve client name from database.
 */
function _support_client($clid) {
  static $client_name = array();

  if (!isset($client_name[$clid])) {
    $client_name[$clid] = db_result(db_query('SELECT name FROM {jobtrack_client} WHERE clid = %d', $clid));
  }

  return $client_name[$clid];
}

/**
 * Fetch mail for a specific client.
 */
function support_client_fetch($client, $manual = TRUE) {
  set_time_limit(0);
  if ($manual) {
    drupal_set_message(t('Fetching mail for !client...', array('!client' => $client->name)));
  }

  $connect = '{'. $client->server_name .':'. $client->port;
  $username = $client->server_username;
  $password = $client->server_password;
  switch ($client->protocol) {
    case 0: // POP3
      $connect .= '/pop3/novalidate-cert}'. $client->mailbox;
      break;
    case 1: // POP3S
      $connect .= '/pop3/ssl/novalidate-cert}'. $client->mailbox;
      break;
    case 2: // IMAP
      $connect .= '/novalidate-cert}'. $client->mailbox;
      break;
    case 3: // IMAPS
      $connect .= '/imap/ssl/novalidate-cert}'. $client->mailbox;
      break;
    case 4: // Local file
      $connect = $client->mailbox;
      $username = $password = '';
      // sanity tests
      if (!file_exists($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" does not exist.', array('%connect' => $connect)), 'error');
      }
      else if (!is_readable($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" is not readable.', array('%connect' => $connect)), 'error');
      }
      else if (!is_writable($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" is not writable.', array('%connect' => $connect)));
      }
      break;
  }

  // Make a connection to the mail server.
  $stream = imap_open($connect, $username, $password);
  if ($stream === FALSE) {
    drupal_set_message(t('Failed to download messages for %client, connection to mail server failed.', array('%client' => $client->name), 'error'));
    if ($alerts = imap_alerts()) {
      foreach ($alerts as $alert) {
        drupal_set_message(t('Imap alert: %alert>', array('%alert' => $alert)), 'error');
      }
    }
    if ($errors = imap_errors()) {
      foreach ($errors as $error) {
        drupal_set_message(t('Imap error: %error', array('%error' => $error)), 'error');
      }
    }
    return (-1);
  }

  $messages_downloaded = 0;
  // check how many messages are available
  $messages_to_download = imap_num_msg($stream);
  $messages_limit = variable_get('support_download_limit', 1000);
  if ($messages_limit && $messages_limit < $messages_to_download) {
    // TODO: watchdog, there are more messages available
    $messages_to_download = $messages_limit;
  }

  for ($message = 1; $message <= $messages_to_download; $message++) {
    $header = imap_headerinfo($stream, $message);

    if (is_array($header->from)) {
      $from = $header->from[0]->mailbox .'@'. $header->from[0]->host;
    }
    $subject = $header->subject;
    $key = variable_get('support_key', 'tkt');
    preg_match("/(\[$key:)([0-9]*)(\])/", $subject, &$tickets);
    $ticket = $tickets[2];

    $structure = imap_fetchstructure($stream, $message);
    $body = _support_get_message_body($stream, $message, $structure);

    $saved = support_save_message($subject, $body, $from, $ticket, $client);

    $messages_downloaded++;

    // mark message for deletion
    imap_delete($stream, $message);
  }
  imap_close($stream, CL_EXPUNGE);

  if ($manual) {
    drupal_goto('admin/support/clients');
  }
}

/**
 *
 */
function _support_access_tickets() {
  static $count = NULL;
  if (is_null($count)) {
    $count = 0;
    $result = db_query('SELECT name FROM {jobtrack_client} WHERE status = 1');
    while ($client = db_fetch_object($result)) {
      if (user_access("access $client->name tickets")) {
        $count++;
      }
    }
  }
  return $count;
}
